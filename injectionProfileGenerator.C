/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Copyright (C) 2020 OpenFOAM Foundation
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

Application
    injectionProfileGenerator
	
Injection Profile was generated by Leilei Xu's model,  email: xflyhigh@qq.com
Please cite the paper:
Xu L, Bai X S, Jia M, et al. Experimental and modeling study of liquid fuel injection and combustion in diesel engines with a common rail injection system[J]. Applied Energy, 2018, 230: 287-304.
DOI: 10.1016/j.apenergy.2018.08.104

Description

\*---------------------------------------------------------------------------*/

#include "fvCFD.H"
#include "dynamicFvMesh.H"
#include "basicSprayCloud.H"
#include "psiReactionThermo.H"


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
	mkDir("constant/injetionParameter");
	OFstream injectionOutPut_dummy("constant/injetionParameter/flowRateProfile");
	OFstream durationOutPut_dummy("constant/injetionParameter/duration");    
    OFstream injVelocityOutPutOutPut_dummy("constant/injetionParameter/velocity");   
    OFstream injDischargeOutPutOutPut_dummy("constant/injetionParameter/discd"); 	
	durationOutPut_dummy<<"10;"<<endl;	
	injVelocityOutPutOutPut_dummy<<"1.0;"<<endl;
    injDischargeOutPutOutPut_dummy<<"0.8;"<<endl;	
	injectionOutPut_dummy<<"table"<<endl;
	injectionOutPut_dummy<<"("<<endl;
	injectionOutPut_dummy<<"(0 1)"<<endl;
	injectionOutPut_dummy<<"(1000 1)"<<endl;
	injectionOutPut_dummy<<");"<<endl;
	
    #include "setRootCaseLists.H"
    #include "createTime.H"
    #include "createDynamicFvMesh.H"
    #include "createFields.H"

IOdictionary sprayCloudProperties
(
    IOobject
    (
        "sprayCloudProperties",
        runTime.constant(),
        mesh,
        IOobject::READ_IF_PRESENT,
        IOobject::NO_WRITE
    )
);    

    const dictionary& subModelDict = parcels.subModelProperties();
    scalar Pinj = readScalar(subModelDict.subDict
    (
        "injectionModels"
    ).subDict("model1").lookup("Pinj"));
    Info<<"Pinj ==="<<Pinj<<endl;
   
    scalar T_fuel = readScalar(sprayCloudProperties.subDict("constantProperties").lookup("T0"));
    scalar viscosity_fuel =
        parcels.composition().liquids().mu
        (
            p[0],
            T_fuel,
            parcels.composition().liquids().X(parcels.composition().YMixture0())
        );   
    Info<<"viscosity_fuel ==="<<viscosity_fuel<<endl;
    scalar rho_fuel =
        parcels.composition().liquids().rho
        (
            p[0],
            T_fuel,
            parcels.composition().liquids().X(parcels.composition().YMixture0())
        );   

    Info<<"rho_fuel ==="<<rho_fuel<<endl;        
    
    scalar numnoz = parcels.injectors().size();
    scalar dOuter = readScalar(subModelDict.subDict
    (
        "injectionModels"
    ).subDict("model1").lookup("dOuter"));
    scalar umbreangle = readScalar(subModelDict.subDict
    (
        "injectionModels"
    ).subDict("model1").lookup("umbreangle"));  
    scalar m_f = readScalar(subModelDict.subDict
    (
        "injectionModels"
    ).subDict("model1").lookup("massTotal"));     
    
    // the parameter of the model

    scalar tcdinj = 0.0;  // injection duration 
    scalar coef1 = 0.28;
    scalar coef2 = 2.7;
    scalar error = 0.001;
    scalar dtt=0.0001;
    
//scalar numvel = 100.0;
scalar numvel = subModelDict.subDict
    (
        "injectionModels"
    ).subDict("model1").lookupOrDefault<scalar>("numvel",100.);  

m_f = m_f*1e6; // mg

scalar vmax = Foam::sqrt(2*Pinj/rho_fuel);
scalar Re = 10000./(vmax*rho_fuel*dOuter/viscosity_fuel);
scalar cd = (0.76-0.05*Foam::log(Re))*Foam::exp(0.08*(90-umbreangle/2)/90);
vmax = cd*vmax;
scalar gmax = vmax*rho_fuel*Foam::constant::mathematical::pi*0.25*Foam::sqr(dOuter)*1e3;
Info<<"gmax(mg/ms) ==="<<gmax<<endl; 
scalar c1 = 7.*gmax;
scalar t1 = 2.*gmax/c1/(coef2-1.0);
scalar t2 = coef2*t1;
scalar b2 = coef1*coef2*c1/(coef2-1.0);
scalar a2 = -b2/2.0/t2;
scalar c2 = gmax-a2*Foam::sqr(t2)-b2*t2;
scalar a1 = 0.25*Foam::sqr(coef2-1.0)*(2.0-coef2+coef1*coef2)*Foam::pow(c1, 3)/Foam::sqr(gmax);
scalar b1 = 0.5*(coef1*c1-c1-3.0*a1*Foam::sqr(t1))/t1;
    
    
scalar topen=t1;
scalar ratio4=0.1*Foam::sqr(topen)-0.32*topen+0.40;
scalar t4=ratio4*topen;
scalar ratio5=-0.1*topen+0.14;
scalar t5=ratio5*topen;
scalar gtopen=a1*Foam::pow(topen,3)+b1*Foam::sqr(topen)+c1*topen;
scalar gm_4=a1/4*Foam::pow(topen,4)+b1/3*Foam::pow(topen,3)+c1/2*Foam::sqr(topen);
scalar a4=-gtopen/(t4*(2*t5+t4));
scalar a5=2*a4*t4;
scalar gm04=a4/3*Foam::pow(t4,3)+gtopen*(topen+t4)-gtopen*topen+gm_4+0.5*(gtopen+a4*t4*t4)*t5;
    
topen = t2;
ratio4 = 0.1*Foam::sqr(topen)-0.32*topen+0.40;
t4 = ratio4*topen;
ratio5=-0.1*topen+0.14;
t5=ratio5*topen;
tcdinj=topen+t4+t5;
gtopen=a2*Foam::sqr(topen)+b2*topen+c2;
a4=-gtopen/(t4*(2*t5+t4));
a5=2*a4*t4;
scalar gm12=a2/3*Foam::pow(topen,3)+b2/2*Foam::sqr(topen)+c2*topen-(a2/3*Foam::pow(t1,3.)+b2/2.*Foam::sqr(t1)+c2*t1)+a4/3*Foam::pow(t4,3.)+gtopen*(topen+t4)-gtopen*topen+0.5*(gtopen+a4*Foam::sqr(t4))*t5+gm_4;

scalar gt=0.;
scalar tcdinj2=0;	
scalar t=0.0;
scalar dt=0.;
scalar gm=0.;

scalarList veltab(numvel);

if(m_f>gm12)
{
    scalar dertam=m_f-gm12;
    scalar dertat=dertam/gmax;
      tcdinj=tcdinj+dertat;
      topen=t2+dertat;
      tcdinj2=topen+t4;	
      dt=tcdinj/(numvel-1);
	  for ( int i=0;i<numvel;i++)
	  {
		if(t<=t1) gt=a1*Foam::pow(t,3)+b1*Foam::sqr(t)+c1*t;
	    if(t>t1 && t<=t2) gt=a2*Foam::sqr(t)+b2*t+c2;
	    if(t>t2 && t<=topen) gt=gmax;
	    if(t>topen && t1<=tcdinj2)
			{
				t=t-dertat;
				gt=a4*(t-t2)*(t-t2)+gmax;
				t=t+dertat;
			}
	    if(t>tcdinj2 && t<tcdinj) gt=gmax+a4*Foam::sqr(t4)+a5*(t-tcdinj2);
	    veltab[i]=gt;
	    t=t+dt;
	  }
}
else if(m_f<=gm04)
{
	t=0.002;
	for (int i=0;i<10000000;i++)
	{
		topen=t;
        ratio4=0.1*Foam::sqr(topen)-0.32*topen+0.40;
        t4=ratio4*topen;
        ratio5=-0.1*topen+0.14;
        t5=ratio5*topen;
        gtopen=a1*Foam::pow(topen,3)+b1*Foam::sqr(topen)+c1*topen;
        gm=a1/4*Foam::pow(topen,4)+b1/3*Foam::pow(topen,3)+c1/2*Foam::sqr(topen);
        a4=-gtopen/(t4*(2*t5+t4));
        a5=2*a4*t4;
        gm=a4/3*Foam::pow(t4,3)+gtopen*(topen+t4)-gtopen*topen+gm+0.5*(gtopen+a4*t4*t4)*t5;
        if (abs(m_f-gm)<=error)
		{
			tcdinj=topen+t4+t5;
            tcdinj2=topen+t4;
            break;
		}
		t=t+dtt;
	}
	t=0.0;
    dt=tcdinj/(numvel-1);  
	for ( int i=0;i<numvel;i++)
	  {
		if(t<=topen) gt=a1*Foam::pow(t,3)+b1*Foam::sqr(t)+c1*t;
	    if(t>topen && t<=tcdinj2) gt=a4*(t-topen)*(t-topen)+gtopen;
	    if(t>tcdinj2 && t<=tcdinj) gt=gtopen+a4*Foam::sqr(t4)+a5*(t-tcdinj2);
	    veltab[i]=gt;
	    t=t+dt;
	  }
}
else if(m_f>gm04 && m_f<=gm12)
{
	t=t1;
	for (int i=0;i<10000000;i++)
	{
		topen=t;
        ratio4=0.1*Foam::sqr(topen)-0.32*topen+0.40;
        t4=ratio4*topen;
        ratio5=-0.1*topen+0.14;
        t5=ratio5*topen;
        gtopen=a2*Foam::sqr(topen)+b2*topen+c2;
        a4=-gtopen/(t4*(2*t5+t4));
        a5=2*a4*t4;
        gm=a2/3*Foam::pow(topen,3)+b2/2*Foam::sqr(topen)+c2*topen-(a2/3*Foam::pow(t1,3)+b2/2*Foam::sqr(t1)+c2*t1)+a4/3*Foam::pow(t4,3)+gtopen*(topen+t4)-gtopen*topen+0.5*(gtopen+a4*Foam::pow(t4,2))*t5+gm_4;
        if (abs(m_f-gm)<=error)
		{
			tcdinj=topen+t4+t5;
            tcdinj2=topen+t4;
            break;
		}
		t=t+dtt;
	}
	t=0.0;
    dt=tcdinj/(numvel-1);
	for ( int i=0;i<numvel;i++)
	{
		if(t<=t1) gt=a1*Foam::pow(t,3)+b1*Foam::sqr(t)+c1*t;
	    if(t>t1 && t<=topen) gt=a2*Foam::sqr(t)+b2*t+c2;
	    if(t>topen && t<=tcdinj2) gt=a4*Foam::sqr(t-topen)+gtopen;
		if(t>tcdinj2 && t<tcdinj) gt=gtopen+a4*Foam::sqr(t4)+a5*(t-tcdinj2);
	    veltab[i]=gt;
	    t=t+dt;
	}
}

    IOobject engineGeometry
    (
        "engineGeometry",
        runTime.constant(),
        mesh,
        IOobject::MUST_READ_IF_MODIFIED,
        IOobject::NO_WRITE,
        false
    );
    
    dimensionedScalar rpm(dimensionSet(0, 0, -1, 0, 0, 0, 0),0);
    scalar duration_CA= 0;
    if (engineGeometry.typeHeaderOk<IOdictionary>(false))
    {
        Info<< "engineGeometry found, so we are in ICE!"
            << endl;        
        IOdictionary(engineGeometry).lookup("rpm") >> rpm;
		Info<<"rpm ==="<<rpm<<endl;
        duration_CA = rpm.value()*tcdinj*6./1000.;
    }
    else
    {
        Info<< "engineGeometry not found, so we are in constant volume vessel!"
            << endl;
        duration_CA=tcdinj/1000.;
    }
    
    
veltab[numvel-1]=0.;
veltab[numvel]=0.;

Info<<"Injection duration ====" << duration_CA  <<endl;

scalarList timeList(numvel, 0);
for ( int i=1;i<numvel;i++)
{
    timeList[i] = timeList[i-1] + duration_CA/(numvel-1);
}


forAll(timeList, i)
{
    Info<< i << tab << timeList[i] << tab << veltab[i] <<endl;
}

OFstream injectionOutPut("constant/injetionParameter/flowRateProfile");
OFstream durationOutPut("constant/injetionParameter/duration");    

injectionOutPut<<"table"<<endl;
injectionOutPut<<"("<<endl;

forAll(timeList, i)
{
    injectionOutPut<<"("<<timeList[i]<<tab<<veltab[i]<<")"<<endl;
}
injectionOutPut<<"("<<1000.<<tab<<veltab[numvel]<<")"<<endl;
injectionOutPut<<");"<<endl;
durationOutPut<< duration_CA <<";"<<endl;

OFstream injVelocityOutPut("constant/injetionParameter/velocity");
injVelocityOutPut<< vmax <<";"<<endl;
OFstream injDischargeOutPutOutPut("constant/injetionParameter/discd");
injDischargeOutPutOutPut<<"constant "<< cd <<";"<<endl;

    Info<< "End\n" << endl;

    return 0;
}


// ************************************************************************* //
